# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/cli.ipynb.

# %% auto 0
__all__ = ['StartProject', 'Export', 'StartApp', 'LitManagementUtility', 'cli']

# %% ../nbs/cli.ipynb 4
from collections import defaultdict
import sys

import django
from django.conf import settings
from django.core.management import ManagementUtility, get_commands
from django.core.management.base import BaseCommand
from django.core.management.color import color_style
from django.core.management.commands.startapp import Command as StartApp
from django.core.management.commands.startproject import Command as StartProject
from nbdev.export import nb_export
from pathlib import Path

from .utils import LITDJANGO_ROOT, get_project_config, get_project_root

# %% ../nbs/cli.ipynb 7
class StartProject(StartProject):
    rewrite_template_suffixes = (('.py-tpl', '.py'), (('.ipynb-tpl', '.ipynb')))

    def handle(self, **options):
        options["template"] = str(LITDJANGO_ROOT / "templates" / "project_template")
        options["extensions"] = ['py', 'txt', 'ipynb', 'ini']
        super().handle(**options)

# %% ../nbs/cli.ipynb 13
class Export(BaseCommand):
    help = "Export .ipynb notebooks to .py modules"
    requires_system_checks = []
    
    def handle(self, *args, **options):
        if not settings.configured:
            settings.configure()
            django.setup()
        self.stdout.write("Exporting...")
        path = Path.cwd()
        cfg = get_project_config(path)
        project_root = get_project_root(path)
        lib_path = project_root / cfg["lib_name"]
        nbs_path = project_root / cfg["nbs_path"]
        notebooks = [nb for nb in nbs_path.glob("**/*.ipynb")]
        for nb in notebooks: nb_export(nb, lib_path)

# %% ../nbs/cli.ipynb 16
class StartApp(StartApp):
    pass

# %% ../nbs/cli.ipynb 18
lit_commands = {
    "startapp": StartApp(), # overrides django default
    "export": Export(), # new command
    "startproject": StartProject() #overrides django default
}

# %% ../nbs/cli.ipynb 19
class LitManagementUtility(ManagementUtility):
    """The litdjango cli is an instance of this class
    
    We use the lit_commands dict as a container for new litdjango commands, or 
    overridden django commands, and fallback to the default django command for anything
    else.
    """
    def __init__(self, argv=None):
        super().__init__(argv)
        
    def main_help_text(self, commands_only=False):
        """Return the script's main help text, as a string."""
        if commands_only:
            usage = sorted(set(get_commands()) | set(lit_commands))  # overwrite django
        else:
            usage = [
                "",
                "Type '%s help <subcommand>' for help on a specific subcommand." % self.prog_name,
                "",
                "Available subcommands:",           
                ]
            commands_dict = defaultdict(lambda: []) 
            commands_dict["litdjango"] = sorted(lit_commands.keys())
            for name, app in get_commands().items():
                if app == "django.core":
                    if name in lit_commands.keys():
                        continue
                    else:
                        app = "django"
                else:
                    app = app.rpartition(".")[-1]
                commands_dict[app].append(name)
            style = color_style()
            for app in sorted(commands_dict):
                usage.append("")
                usage.append(style.NOTICE("[%s]" % app))
                for name in sorted(commands_dict[app]):
                    usage.append("    %s" % name)
            # Output an extra note if settings are not properly configured
            if self.settings_exception is not None:
                usage.append(
                    style.NOTICE(
                        "Note that only Django core commands are listed "
                        "as settings are not properly configured (error: %s)."
                        % self.settings_exception
                    )
                )
        return "\n".join(usage)

    def fetch_command(self, subcommand):
        """Use lit_commands version if it exists, otherwise fallback to django commands"""
        try: # find a lit_command version of the command
            return lit_commands[subcommand]
        except KeyError:
            # Fall back to default django  if we have not defined a custom command
            return super().fetch_command(subcommand)

# %% ../nbs/cli.ipynb 20
def cli():
    """This is set as entrypoint of the litdjango command in the package's setup.py"""
    utility = LitManagementUtility(sys.argv)
    utility.execute()
